"""
Ragie Client - Retrieves relevant context from Gus Baha knowledge base.
Simple wrapper around Ragie.ai API.
"""

import os
import requests

RAGIE_API_KEY = os.environ.get("RAGIE_API_KEY")
RAGIE_BASE_URL = "https://api.ragie.ai"


def retrieve_context(query: str, top_k: int = 6) -> list[dict]:
    """
    Retrieve relevant chunks from Ragie.
    
    Args:
        query: User's question in Bahasa Indonesia
        top_k: Number of chunks to retrieve (default 6)
    
    Returns:
        List of chunk dictionaries with 'text' and 'score'
    """
    if not RAGIE_API_KEY:
        print("Warning: RAGIE_API_KEY not set")
        return []
    
    headers = {
        "Authorization": f"Bearer {RAGIE_API_KEY}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "query": query,
        "top_k": top_k,
        "partition": "gus-baha"  # The partition you created in Ragie
    }
    
    try:
        response = requests.post(
            f"{RAGIE_BASE_URL}/retrievals",
            headers=headers,
            json=payload,
            timeout=10
        )
        response.raise_for_status()
        
        data = response.json()
        chunks = data.get("scored_chunks", [])
        
        # Extract just what we need
        results = []
        for chunk in chunks:
            results.append({
                "text": chunk.get("text", ""),
                "score": chunk.get("score", 0),
                "source": chunk.get("document_name", "unknown")
            })
        
        return results
        
    except requests.exceptions.RequestException as e:
        print(f"Ragie retrieval error: {e}")
        return []


def format_context_for_prompt(chunks: list[dict], max_chars: int = 3000) -> str:
    """
    Format retrieved chunks into a context string for the LLM.
    
    Args:
        chunks: List of chunk dictionaries from retrieve_context()
        max_chars: Maximum characters to include
    
    Returns:
        Formatted context string
    """
    if not chunks:
        return ""
    
    context_parts = []
    total_chars = 0
    
    for i, chunk in enumerate(chunks, 1):
        text = chunk.get("text", "").strip()
        source = chunk.get("source", "unknown")
        
        # Determine label based on source
        if "10_refined" in source or "ajaran" in source.lower():
            label = "AJARAN INTI"
        else:
            label = "NGAJI GUS BAHA"
        
        # Truncate individual chunk if too long
        if len(text) > 800:
            text = text[:800] + "..."
        
        block = f"[{label} {i}]\n{text}"
        
        if total_chars + len(block) > max_chars:
            break
            
        context_parts.append(block)
        total_chars += len(block)
    
    return "\n\n".join(context_parts)