"""
Ragie Client - Retrieves relevant context from Gus Baha knowledge base.
Includes source metadata for citations.
Supports: YouTube videos, books, summaries
"""

import os
import requests

RAGIE_API_KEY = os.environ.get("RAGIE_API_KEY")
RAGIE_BASE_URL = "https://api.ragie.ai"

# Source metadata for citations
SOURCES = {
    # ==================
    # YOUTUBE VIDEOS
    # ==================
    "gus_baha_full_transcript.txt": {
        "title": "Ngaji Penuh Humor Ilmiah Gus Baha' bersama Prof Quraish Shihab",
        "url": "https://www.youtube.com/watch?v=RHnuHSFOeNw",
        "channel": "NU Online",
        "date": "1 Oktober 2025",
        "type": "video"
    },
    "gusbaha_10_refined.md": {
        "title": "10 Ajaran Inti Gus Baha (Distilasi)",
        "url": "https://www.youtube.com/watch?v=RHnuHSFOeNw",
        "channel": "NU Online",
        "date": "1 Oktober 2025",
        "type": "summary"
    },
    
    # ==================
    # BOOKS
    # ==================
    "IslamSantuy_HTI_GusBaha.txt": {
        "title": "Islam Santuy Ala Gus Baha - Pandangan tentang HTI",
        "url": None,
        "author": "Muhammad Khoirul Huda",
        "book": "Islam Santuy Ala Gus Baha",
        "pages": "151-154",
        "date": None,
        "type": "book"
    },
    "IslamSantuy_DikotomiIlmu_GusBaha.txt": {
        "title": "Islam Santuy Ala Gus Baha - Dikotomi Ilmu Pengetahuan",
        "url": None,
        "author": "Habib Maulana Maslahul Adi",
        "book": "Islam Santuy Ala Gus Baha",
        "pages": "99-103",
        "date": None,
        "type": "book"
    },
}

# Partial match patterns for flexible source detection
SOURCE_PATTERNS = {
    "IslamSantuy": {
        "title": "Islam Santuy Ala Gus Baha",
        "url": None,
        "book": "Islam Santuy Ala Gus Baha",
        "type": "book"
    },
    "HTI": {
        "title": "Pandangan Gus Baha tentang HTI",
        "url": None,
        "book": "Islam Santuy Ala Gus Baha",
        "type": "book"
    },
    "Dikotomi": {
        "title": "Dikotomi Ilmu Pengetahuan",
        "url": None,
        "book": "Islam Santuy Ala Gus Baha",
        "type": "book"
    },
    "transcript": {
        "title": "Ngaji Gus Baha bersama Prof Quraish Shihab",
        "url": "https://www.youtube.com/watch?v=RHnuHSFOeNw",
        "channel": "NU Online",
        "type": "video"
    },
    "refined": {
        "title": "10 Ajaran Inti Gus Baha",
        "url": "https://www.youtube.com/watch?v=RHnuHSFOeNw",
        "channel": "NU Online",
        "type": "summary"
    }
}


def get_source_metadata(document_name: str) -> dict:
    """Get source metadata for a document."""
    if not document_name:
        return _default_source()
    
    # Try exact match first
    if document_name in SOURCES:
        return SOURCES[document_name]
    
    # Try partial match on full path/name
    for key, value in SOURCES.items():
        if key in document_name or document_name in key:
            return value
    
    # Try pattern matching
    doc_lower = document_name.lower()
    for pattern, meta in SOURCE_PATTERNS.items():
        if pattern.lower() in doc_lower:
            return meta
    
    # Default fallback
    return _default_source()


def _default_source() -> dict:
    """Default source when no match found."""
    return {
        "title": "Pengajian Gus Baha",
        "url": None,
        "type": "unknown"
    }


def retrieve_context(query: str, top_k: int = 6) -> list[dict]:
    """
    Retrieve relevant chunks from Ragie with source metadata.
    """
    if not RAGIE_API_KEY:
        print("Warning: RAGIE_API_KEY not set")
        return []
    
    headers = {
        "Authorization": f"Bearer {RAGIE_API_KEY}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "query": query,
        "top_k": top_k,
        "partition": "gus-baha"
    }
    
    try:
        response = requests.post(
            f"{RAGIE_BASE_URL}/retrievals",
            headers=headers,
            json=payload,
            timeout=10
        )
        response.raise_for_status()
        
        data = response.json()
        chunks = data.get("scored_chunks", [])
        
        results = []
        for chunk in chunks:
            doc_name = chunk.get("document_name", "unknown")
            source_meta = get_source_metadata(doc_name)
            
            results.append({
                "text": chunk.get("text", ""),
                "score": chunk.get("score", 0),
                "document_name": doc_name,
                "source": source_meta
            })
        
        return results
        
    except requests.exceptions.RequestException as e:
        print(f"Ragie retrieval error: {e}")
        return []


def format_context_for_prompt(chunks: list[dict], max_chars: int = 3000) -> str:
    """Format retrieved chunks into a context string for the LLM."""
    if not chunks:
        return ""
    
    context_parts = []
    total_chars = 0
    
    for i, chunk in enumerate(chunks, 1):
        text = chunk.get("text", "").strip()
        doc_name = chunk.get("document_name", "unknown")
        source = chunk.get("source", {})
        source_type = source.get("type", "unknown")
        
        # Determine label based on source type
        if source_type == "book":
            book_name = source.get("book", "Buku")
            label = f"BUKU: {book_name}"
        elif source_type == "summary":
            label = "AJARAN INTI"
        elif source_type == "video":
            label = "NGAJI GUS BAHA"
        else:
            label = "SUMBER"
        
        # Truncate if too long
        if len(text) > 800:
            text = text[:800] + "..."
        
        block = f"[{label} {i}]\n{text}"
        
        if total_chars + len(block) > max_chars:
            break
            
        context_parts.append(block)
        total_chars += len(block)
    
    return "\n\n".join(context_parts)


def get_unique_sources(chunks: list[dict]) -> list[dict]:
    """Extract unique sources from chunks for citation display."""
    seen_titles = set()
    unique_sources = []
    
    for chunk in chunks:
        source = chunk.get("source", {})
        title = source.get("title", "")
        source_type = source.get("type", "unknown")
        
        # Create unique key based on title (for books without URL)
        unique_key = title or source.get("url", "") or source.get("book", "")
        
        if unique_key and unique_key not in seen_titles:
            seen_titles.add(unique_key)
            
            # Build citation based on source type
            if source_type == "book":
                unique_sources.append({
                    "title": title,
                    "url": source.get("url"),  # Will be None for books
                    "author": source.get("author", ""),
                    "book": source.get("book", ""),
                    "pages": source.get("pages", ""),
                    "type": "book"
                })
            else:
                unique_sources.append({
                    "title": title,
                    "url": source.get("url", ""),
                    "channel": source.get("channel", ""),
                    "date": source.get("date", ""),
                    "type": source_type
                })
    
    return unique_sources